//-------------------------------------------------------------
//--------- Descodifica a informação ----------------
void decodeDataBytes(HuffmanTree* huffTreeLiteral, HuffmanTree* huffTreeDistance, char *ficheiro, int *frontFile, unsigned int *rb, char *availBits, FILE *gzFile)
{
	int index;
	int copy;
	int dist;
	int recua;
	char needBits;
	unsigned char bits;

	index = -1;
	while(index != 256)
	{
		resetCurNode(huffTreeLiteral);

		while(index < 0)
		{
			needBits = 1;
			getByte(rb, availBits, needBits, gzFile);
			bits = (*rb & 0x01) + 48;	//máscara 00000001 + 48 (equivalente a ASCII)
			*rb = *rb >> 1;
			(*availBits) -= 1;

			index = nextNode(huffTreeLiteral, bits);

			if(index < 257)
			{
				ficheiro[*frontFile] = index;
				printf("%c", ficheiro[*frontFile]);
			}
			else
			{
				if(index == 256)
				{
					break;
				}
				else if(index >= 257 && index <= 285)
				{
					copy = decodeLen(index, huffTreeLiteral, rb, availBits, gzFile);
					dist = decodeDist(index, huffTreeDistance, rb, availBits, gzFile);

					recua = *frontFile - dist;
					for(int i = 0; i < copy; i++)
					{
						ficheiro[*frontFile] = ficheiro[recua + 1];
						printf("%c", ficheiro[*frontFile]);
						(*frontFile)++;
					}
				}
			}

		}
	}
}
//-------------------------------------------------------------
//--------- Calcula a distância a copiar ----------------
int decodeLen(int index, HuffmanTree* huffTreeLiteral, unsigned int *rb, char *availBits, FILE *gzFile)
{
	int len[29] = {3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};
	int comp;
	char needBits;
	unsigned char bits;

	if(index >= 257 && index <= 264)
	{
		comp = len[index - 257];
	}
	else if(index >= 265 && index <= 284)
	{
		needBits = ((index - 265) / 4) + 1;
		getByte(rb, availBits, needBits, gzFile);
		bits = (*rb << (8 - needBits));	//coloca uma máscara nos bits que são precisos para ler
		bits = bits >> (8 - needBits);
		*rb = *rb >> needBits;
		(*availBits) -= needBits;

		comp = len[index - 257] + bits;
	}
	else if(index == 285)
	{
		comp = len[index - 257];
	}
	return comp;	
}
//-------------------------------------------------------------
//--------- Calcula a distância ----------------
int decodeDist(int index, HuffmanTree* huffTreeDistance, unsigned int *rb, char *availBits, FILE *gzFile)
{
	int dist[30] = {1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577};
	int recua;
	char needBits;
	unsigned char bits;

	if(index >= 0 && index <= 3)
	{
		recua = dist[index];
	}
	else if(index >= 4 && index <= 29)
	{
		needBits = ((index - 4) / 2) + 1;
		getByte(rb, availBits, needBits, gzFile);
		bits = (*rb << (8 - needBits));	//coloca uma máscara nos bits que são precisos para ler
		bits = bits >> (8 - needBits);
		*rb = *rb >> needBits;
		(*availBits) -= needBits;

		recua = dist[index] + bits;
	}
	return recua;
}
